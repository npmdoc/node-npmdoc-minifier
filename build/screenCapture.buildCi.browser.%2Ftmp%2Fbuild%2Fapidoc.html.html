<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/fizker/minifier#readme">minifier (v0.8.1)</a>
</h1>
<h4>A simple tool for minifying CSS/JS without a big setup</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.minifier">module minifier</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.generateOutputName">
            function <span class="apidocSignatureSpan">minifier.</span>generateOutputName
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.minify">
            function <span class="apidocSignatureSpan">minifier.</span>minify
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minifier.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.</span>css</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minifier.css">module minifier.css</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.css.parse">
            function <span class="apidocSignatureSpan">minifier.css.</span>parse
            <span class="apidocSignatureSpan">(file, absRoot, minifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minifier.minify">module minifier.minify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.minify.minify">
            function <span class="apidocSignatureSpan">minifier.</span>minify
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.minify.generateOutputName">
            function <span class="apidocSignatureSpan">minifier.minify.</span>generateOutputName
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minifier.minify.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.minify.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minifier.minify.</span>domain</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minifier.utils">module minifier.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.utils.generateOutputName">
            function <span class="apidocSignatureSpan">minifier.utils.</span>generateOutputName
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minifier.utils.stripUTF8ByteOrder">
            function <span class="apidocSignatureSpan">minifier.utils.</span>stripUTF8ByteOrder
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minifier" id="apidoc.module.minifier">module minifier</a></h1>


    <h2>
        <a href="#apidoc.element.minifier.generateOutputName" id="apidoc.element.minifier.generateOutputName">
        function <span class="apidocSignatureSpan">minifier.</span>generateOutputName
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateOutputName(input, options) {
	if(!options) options = {}
	var extractedInput =
		{ md5: generate.bind(null, 'md5')
		, sha: generate.bind(null, 'sha256')
		}
	var dir = path.dirname(input)
	path.basename(input).replace(/^(.*)\.([^.]+)$/, function(match, file, ext) {
		extractedInput.ext = ext
		extractedInput.filename = file
		return ''
	})

	var output = hogan.compile(options.template || '{{filename}}.min.{{ext}}').render(extractedInput)

	output = path.join(dir, output)

	if(options.regex) return new RegExp(output.replace(/\.([^*])/g, '\\.$1'))
	return output

	function generate(algorithm) {
		if(options.regex) return '.*'
		if(options.glob) return '*'
		if(!options.content) throw new Error('Content is required for producing ' + algorithm)
		var digester = digest(algorithm)
		digester.update(options.content, 'utf8')
		return digester.digest('hex')
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The method for building the output name from the template is exposed for
convenience:

	var minifier = require('minifier')
	var file = 'abc.js'
	var template = '{{filename}}.{{md5}}.{{ext}}'
	var content = null; // or the content, if md5 or sha1 should be calculated
	var result = minifier.<span class="apidocCodeKeywordSpan">generateOutputName</span>(file, { template: template, content: content
 })

If the input-path includes any folders, they will also be added to the output.

If `content` is eschewed, the `md5` and `sha` digests cannot be calculated.

But there is an option for turning them into either `RegExp` or `glob` compatible
syntax: Simply add `glob: true` or `regex: true` to the options array:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minifier.minify" id="apidoc.element.minifier.minify">
        function <span class="apidocSignatureSpan">minifier.</span>minify
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minify(input, options) {
	options = fmerge({}, options)

	var output
	var template

	if(!input || (Array.isArray(input) &amp;&amp; input.length == 0)) {
		obj.emit('error', new Error('The input is required'))
	}

	if(options.cleanOnly) {
		options.clean = true
	}
	output = options.output
	template = options.template

	if(output &amp;&amp; template) {
		return obj.emit(
			  'error'
			,   new Error('It does not make sense to provide both --output and '
			  + '--template options. Please choose one.')
		)
	}

	if(!Array.isArray(input) &amp;&amp; fs.statSync(input).isDirectory()) {
		if(output) {
			return obj.emit('error',
				new Error('You cannot use `output` option against a directory'))
		}
		if(options.clean) {
			clean(input, template || '{{filename}}.min.{{ext}}')
		}
		if(options.cleanOnly) {
			return
		}

		var files = glob.sync(path.join(input, '**/*.js'))
			.concat(
				glob.sync(path.join(input, '**/*.css'))
			)
		if(options.skip) {
			files = files.filter(function(file) {
				return !options.skip.some(function(filter) {
					return ~file.indexOf(filter)
				})
			})
		}
		files.every(x =&gt; handleInputs([x]))

		return
	}

	var inputs = Array.isArray(input) ? input : [input]

	if(options.clean) {
		if(template) {
			clean(path.dirname(inputs[0]), template)
		} else if(fs.existsSync(output)) {
			fs.unlinkSync(output)
		}
	}

	if(options.cleanOnly) {
		return
	}

	handleInputs(inputs)

	function handleInputs(inputs) {
		var extensionRegex = /(\.js|css)$/

		var usedExtensions = inputs
			.map(function(i) { return i.match(extensionRegex) })
			.filter(function(i) { return i != null })
			.map(function(i) { return i[1] })
			.filter(function(ext, idx, arr) { return arr.indexOf(ext) == idx })

		if(usedExtensions.length &gt; 1) {
			obj.emit('error', new Error('Please only use one type of extension per run'))
			return false
		} else if(usedExtensions.length == 0 || usedExtensions[0].match(extensionRegex) == null) {
			obj.emit('error', new Error('Please reference files with the extension as either .js or .css'))
			return false
		}

		var jsFiles = inputs.filter(x =&gt; x.endsWith('.js'))
		var cssFiles = inputs.filter(x =&gt; x.endsWith('.css'))
		if(jsFiles.length &gt; 0) {
			js(jsFiles)
		}
		if(cssFiles.length &gt; 0) {
			css(cssFiles)
		}
		return true
	}

	function js(inputs) {
		var max = inputs.map(function(input) {
			return stripUTF8ByteOrder(fs.readFileSync(input, 'utf8'))
		}).join(';\n')

		var comment = firstComment(max)
		var min = uglify.minify(max, fmerge(options.uglify, { fromString: true })).code
		var opts = { content: min, template: template }
		var renderedOutput = output || generateOutput(inputs[0], opts)

		if(comment) {
			min = comment +'\n' + min
		}

		fs.writeFileSync(renderedOutput, min)
	}

	function css(inputs) {
		var inDir = path.dirname(inputs[0])
		var outDir = path.dirname(output || inputs[0])
		var root = path.join(inDir, path.relative(inDir, outDir))
		var min = inputs.map(input =&gt; cssParser(input, root, function(max) {
			var max = stripUTF8ByteOrder(max)
			var comment = firstComment(max)
			var min = sqwish.minify(max, false)

			if(comment) {
				min = comment + '\n' + min
			}

			return min
		})).join('\n')
		var opts = { content: min, template: template }
		var renderedOutput = output || generateOutput(inputs[0], opts)

		fs.writeFileSync(renderedOutput, min)
	}

	function clean(dir, template) {
		template = template.replace(/{{[^}]*}}/g, '*')
		glob.sync(path.join(dir, '**', template)).forEach(function(file) {
			fs.unlinkSync(file)
		})
	}

	function firstComment(content) {
		if(options.noComments) return null
		content = content.trim()
		if(content[0] == '/' &amp;&amp; content[1] == '*') {
			return content.substring(0, content.indexOf('*/')+2)
		}
		if(content[0] == '/' &amp;&amp; content[1] == '/') {
			var lines = content.split(/[\r\n]{1,2}/g)
			content = lines[0]
			for(var i = 1; i &lt; lines.length; i++) {
				var line = lines[i]
				if(line[0] == '/' &amp;&amp; line[1] == '/') {
					content += '\n' + line
				}
			}
			return content
		}
		return null
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		process.exit(1)
	})
	program.uglify = {
		output: {
			semicolons:false,
		},
	}
	minifier.<span class="apidocCodeKeywordSpan">minify</span>(input || inputs, program)

	if(program.cleanOnly) {
		return console.log('Minified files cleaned')
	}

	console.log('Minification complete')
}
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minifier.css" id="apidoc.module.minifier.css">module minifier.css</a></h1>


    <h2>
        <a href="#apidoc.element.minifier.css.parse" id="apidoc.element.minifier.css.parse">
        function <span class="apidocSignatureSpan">minifier.css.</span>parse
        <span class="apidocSignatureSpan">(file, absRoot, minifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(file, absRoot, minifier) {
	if(!minifier) minifier = function(content) { return content }
	var root = path.dirname(file)
	var absRoot = absRoot || ''
	var relRoot = path.relative(absRoot, root)
	var content = minifier(utils.stripUTF8ByteOrder(fs.readFileSync(file, 'utf8')))

	return content
		.replace(stringImportMatcher, function(match, url) {
			return format('@import url(%s);', url)
		})
		.replace(urlMatcher, function(match, url) {
			url = url.trim()
			if(!url.match(dataUrl) &amp;&amp; !url.match(absoluteUrl)) {
				url = path.join(relRoot, url).replace(/\\/g, '/')
			}
			return format('url(%s)', url)
		})
		.replace(importMatcher, function(match, junk, file) {
			if(!file.match(absoluteUrl)) {
				file = path.join(absRoot, file)
			}
			var parsedFile = parse(file, absRoot)
			return parsedFile +'\n'
		})
		.trim()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		.option('--no-comments', 'Remove license-style comments')
		.usage('[--output file] path/to/input [...path/to/other/input]')

		.on('skip', function(path) {
			skip.push(path)
		})

		.<span class="apidocCodeKeywordSpan">parse</span>(process.argv)

	var inputs = program.args
	var input
	if(inputs.length == 1) {
		input = inputs[0]
	}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minifier.minify" id="apidoc.module.minifier.minify">module minifier.minify</a></h1>


    <h2>
        <a href="#apidoc.element.minifier.minify.minify" id="apidoc.element.minifier.minify.minify">
        function <span class="apidocSignatureSpan">minifier.</span>minify
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minify(input, options) {
	options = fmerge({}, options)

	var output
	var template

	if(!input || (Array.isArray(input) &amp;&amp; input.length == 0)) {
		obj.emit('error', new Error('The input is required'))
	}

	if(options.cleanOnly) {
		options.clean = true
	}
	output = options.output
	template = options.template

	if(output &amp;&amp; template) {
		return obj.emit(
			  'error'
			,   new Error('It does not make sense to provide both --output and '
			  + '--template options. Please choose one.')
		)
	}

	if(!Array.isArray(input) &amp;&amp; fs.statSync(input).isDirectory()) {
		if(output) {
			return obj.emit('error',
				new Error('You cannot use `output` option against a directory'))
		}
		if(options.clean) {
			clean(input, template || '{{filename}}.min.{{ext}}')
		}
		if(options.cleanOnly) {
			return
		}

		var files = glob.sync(path.join(input, '**/*.js'))
			.concat(
				glob.sync(path.join(input, '**/*.css'))
			)
		if(options.skip) {
			files = files.filter(function(file) {
				return !options.skip.some(function(filter) {
					return ~file.indexOf(filter)
				})
			})
		}
		files.every(x =&gt; handleInputs([x]))

		return
	}

	var inputs = Array.isArray(input) ? input : [input]

	if(options.clean) {
		if(template) {
			clean(path.dirname(inputs[0]), template)
		} else if(fs.existsSync(output)) {
			fs.unlinkSync(output)
		}
	}

	if(options.cleanOnly) {
		return
	}

	handleInputs(inputs)

	function handleInputs(inputs) {
		var extensionRegex = /(\.js|css)$/

		var usedExtensions = inputs
			.map(function(i) { return i.match(extensionRegex) })
			.filter(function(i) { return i != null })
			.map(function(i) { return i[1] })
			.filter(function(ext, idx, arr) { return arr.indexOf(ext) == idx })

		if(usedExtensions.length &gt; 1) {
			obj.emit('error', new Error('Please only use one type of extension per run'))
			return false
		} else if(usedExtensions.length == 0 || usedExtensions[0].match(extensionRegex) == null) {
			obj.emit('error', new Error('Please reference files with the extension as either .js or .css'))
			return false
		}

		var jsFiles = inputs.filter(x =&gt; x.endsWith('.js'))
		var cssFiles = inputs.filter(x =&gt; x.endsWith('.css'))
		if(jsFiles.length &gt; 0) {
			js(jsFiles)
		}
		if(cssFiles.length &gt; 0) {
			css(cssFiles)
		}
		return true
	}

	function js(inputs) {
		var max = inputs.map(function(input) {
			return stripUTF8ByteOrder(fs.readFileSync(input, 'utf8'))
		}).join(';\n')

		var comment = firstComment(max)
		var min = uglify.minify(max, fmerge(options.uglify, { fromString: true })).code
		var opts = { content: min, template: template }
		var renderedOutput = output || generateOutput(inputs[0], opts)

		if(comment) {
			min = comment +'\n' + min
		}

		fs.writeFileSync(renderedOutput, min)
	}

	function css(inputs) {
		var inDir = path.dirname(inputs[0])
		var outDir = path.dirname(output || inputs[0])
		var root = path.join(inDir, path.relative(inDir, outDir))
		var min = inputs.map(input =&gt; cssParser(input, root, function(max) {
			var max = stripUTF8ByteOrder(max)
			var comment = firstComment(max)
			var min = sqwish.minify(max, false)

			if(comment) {
				min = comment + '\n' + min
			}

			return min
		})).join('\n')
		var opts = { content: min, template: template }
		var renderedOutput = output || generateOutput(inputs[0], opts)

		fs.writeFileSync(renderedOutput, min)
	}

	function clean(dir, template) {
		template = template.replace(/{{[^}]*}}/g, '*')
		glob.sync(path.join(dir, '**', template)).forEach(function(file) {
			fs.unlinkSync(file)
		})
	}

	function firstComment(content) {
		if(options.noComments) return null
		content = content.trim()
		if(content[0] == '/' &amp;&amp; content[1] == '*') {
			return content.substring(0, content.indexOf('*/')+2)
		}
		if(content[0] == '/' &amp;&amp; content[1] == '/') {
			var lines = content.split(/[\r\n]{1,2}/g)
			content = lines[0]
			for(var i = 1; i &lt; lines.length; i++) {
				var line = lines[i]
				if(line[0] == '/' &amp;&amp; line[1] == '/') {
					content += '\n' + line
				}
			}
			return content
		}
		return null
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		process.exit(1)
	})
	program.uglify = {
		output: {
			semicolons:false,
		},
	}
	minifier.<span class="apidocCodeKeywordSpan">minify</span>(input || inputs, program)

	if(program.cleanOnly) {
		return console.log('Minified files cleaned')
	}

	console.log('Minification complete')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minifier.minify.generateOutputName" id="apidoc.element.minifier.minify.generateOutputName">
        function <span class="apidocSignatureSpan">minifier.minify.</span>generateOutputName
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateOutputName(input, options) {
	if(!options) options = {}
	var extractedInput =
		{ md5: generate.bind(null, 'md5')
		, sha: generate.bind(null, 'sha256')
		}
	var dir = path.dirname(input)
	path.basename(input).replace(/^(.*)\.([^.]+)$/, function(match, file, ext) {
		extractedInput.ext = ext
		extractedInput.filename = file
		return ''
	})

	var output = hogan.compile(options.template || '{{filename}}.min.{{ext}}').render(extractedInput)

	output = path.join(dir, output)

	if(options.regex) return new RegExp(output.replace(/\.([^*])/g, '\\.$1'))
	return output

	function generate(algorithm) {
		if(options.regex) return '.*'
		if(options.glob) return '*'
		if(!options.content) throw new Error('Content is required for producing ' + algorithm)
		var digester = digest(algorithm)
		digester.update(options.content, 'utf8')
		return digester.digest('hex')
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The method for building the output name from the template is exposed for
convenience:

	var minifier = require('minifier')
	var file = 'abc.js'
	var template = '{{filename}}.{{md5}}.{{ext}}'
	var content = null; // or the content, if md5 or sha1 should be calculated
	var result = minifier.<span class="apidocCodeKeywordSpan">generateOutputName</span>(file, { template: template, content: content
 })

If the input-path includes any folders, they will also be added to the output.

If `content` is eschewed, the `md5` and `sha` digests cannot be calculated.

But there is an option for turning them into either `RegExp` or `glob` compatible
syntax: Simply add `glob: true` or `regex: true` to the options array:
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minifier.utils" id="apidoc.module.minifier.utils">module minifier.utils</a></h1>


    <h2>
        <a href="#apidoc.element.minifier.utils.generateOutputName" id="apidoc.element.minifier.utils.generateOutputName">
        function <span class="apidocSignatureSpan">minifier.utils.</span>generateOutputName
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateOutputName(input, options) {
	if(!options) options = {}
	var extractedInput =
		{ md5: generate.bind(null, 'md5')
		, sha: generate.bind(null, 'sha256')
		}
	var dir = path.dirname(input)
	path.basename(input).replace(/^(.*)\.([^.]+)$/, function(match, file, ext) {
		extractedInput.ext = ext
		extractedInput.filename = file
		return ''
	})

	var output = hogan.compile(options.template || '{{filename}}.min.{{ext}}').render(extractedInput)

	output = path.join(dir, output)

	if(options.regex) return new RegExp(output.replace(/\.([^*])/g, '\\.$1'))
	return output

	function generate(algorithm) {
		if(options.regex) return '.*'
		if(options.glob) return '*'
		if(!options.content) throw new Error('Content is required for producing ' + algorithm)
		var digester = digest(algorithm)
		digester.update(options.content, 'utf8')
		return digester.digest('hex')
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The method for building the output name from the template is exposed for
convenience:

	var minifier = require('minifier')
	var file = 'abc.js'
	var template = '{{filename}}.{{md5}}.{{ext}}'
	var content = null; // or the content, if md5 or sha1 should be calculated
	var result = minifier.<span class="apidocCodeKeywordSpan">generateOutputName</span>(file, { template: template, content: content
 })

If the input-path includes any folders, they will also be added to the output.

If `content` is eschewed, the `md5` and `sha` digests cannot be calculated.

But there is an option for turning them into either `RegExp` or `glob` compatible
syntax: Simply add `glob: true` or `regex: true` to the options array:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minifier.utils.stripUTF8ByteOrder" id="apidoc.element.minifier.utils.stripUTF8ByteOrder">
        function <span class="apidocSignatureSpan">minifier.utils.</span>stripUTF8ByteOrder
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripUTF8ByteOrder(data) {
	var content = data.toString()
	if(content[0] === '\uFEFF') {
		content = content.substring(1)
	}
	return content
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dataUrl = /^data:/

function parse(file, absRoot, minifier) {
	if(!minifier) minifier = function(content) { return content }
	var root = path.dirname(file)
	var absRoot = absRoot || ''
	var relRoot = path.relative(absRoot, root)
	var content = minifier(utils.<span class="apidocCodeKeywordSpan">stripUTF8ByteOrder</span>(fs.readFileSync(file, 'utf8'
;)))

	return content
		.replace(stringImportMatcher, function(match, url) {
			return format('@import url(%s);', url)
		})
		.replace(urlMatcher, function(match, url) {
			url = url.trim()
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>